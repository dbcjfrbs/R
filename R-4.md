```R
# empno 컬럼값을 rowname으로 설정후 empno컬럼 삭제
rownames(df1) <- df1$EMPNO
#1) 컬럼위치값을 아는 경우 컬럼 삭제
df1 <- df1[,-1]
#2) 컬럼위치값을 모르는 경우 컬럼 삭제
df1 <- df1[ , colnames(df1) != 'EMPNO']

--------------------------------------------------------------
1) 첫번째 생성방법
no <- 1:4
name <- c('apple','banana','peach','berry')
price <- c(500,200,200,50)
qty <- c(5,2,7,9)

df2<- data.frame(no=no, 
                 name=name, 
                 price=price, 
                 qty=qty,
                 stringsAsFactors = F) 
2) 두번째 생성방법
df2<-data.frame(no=c(1,2,3,4),
                name=c('apple','banana','peach','berry'),
                price=c(500,200,200,50),qty=c(5,2,7,9),
                stringsAsFactors = F) 
------------------
df2 <- rbind(df2, c(5, 'mango', 100, 10)) # 벡터가 문자형임
# stringsAsFactors = F 선언 안하면 문자추가 안된다 
# 나중에 문자 생겼다면 문제되는 컬럼을 문자형으로 변형시킨다
str(df2) # 모두 문자형으로 변경됨

df2$no <- as.numeric(df2$no) # 한 컬럼씩 바꿔줘야 한다
df2$price <- as.numeric(df2$price)
df2$qty <- as.numeric(df2$qty) 

# vector -> matrix -> array, 동일한데이터 값 허용
# list -> data.frame,  key vlaue 가짐, 다른 데이터 값 가능
```
----------------------------------------
--------------------------------------------
### *array
- 다차원
- 동일 데이터 타입만 허용
```R
#차원의 확장
          R      python
 2차원  행,열     행,열  
 3차원 행,열,충  층,행,열

# 1. array 생성
a1<-array(data=1:12,dim=c(3,4));a1 #3x4
a2<-array(data=1:12,dim=c(2,2,3));a2 #2x2x3

# 2. 색인
a2[1,1,3]
a2[,,3] # 차원 축소됨, drop=F하면 array로 추출

# 3. 차원확인
dim(a2) # 2 2 3 으로 결과나옴
```
--------------------------------------------
-----------------------------------------
### *if문 
- 조건에 따른 치환 또는 다른 프로그래밍 가능!!
- 벡터연산 불가(원소별 조건치환 반복불가)!!
 
**[기본문법]**
 if (조건) {
   참일 때 수행 문자
 } else if (조건) {
   참일 때 수행 문자
 } else {
   거짓일 때 수행 문자
 }
```R
#예제) v1의 값이 30보다 크면 'A' 20보다 크면 'B' 기타는 'C'로 출력
v1<-20

if (v1>30) {
  'A'
} else if (v1>20) {
  'B'
} else {
  'C'
}


#예제) v2의 값이 10이면 'A' 아니면 'B'로 출력
v2<-c(10,20,30) 

if(v2==10) {
  'A'
} else {
  'B'
}
=> length > 1 이라는 조건이있고, 첫번째 요소만이 사용될 것입니다
# if는 벡터를 적용했을 때 모든 원소에 적용되지 않음
```
---------------------------------------------
----------------------------------------------
### *ifelse문
- 조건에 따른 치환, 리턴만 가능!! 연산의 결과가 단 하나로 되야함
- else리턴 생략 불가
- 벡터연산 가능
- if문이 복잡한 프로그래밍 처리하기위한 구문이고 ifelse는 리턴값만 처리
ex) v1<-7 같은 복잡한 프로그래밍 처리는 ifelse가 아닌 if문에서 가능

**[기본문법]**
ifelse(조건, 조건 참일 떄 리턴 값, 거짓일 때리턴값)
```R
#예제) v2의 값이 10이면 'A' 아니면 'B'로 출력
ifelse(v2==10,'A','B') # sql에서의 decode에서는 조건 ,로 구분했음

#예제) v2의 값이 30보다 크면 'A' 20보다 크면 'B' 기타는 'C'로 출력
ifelse(v2>30,'A',ifelse(v2>20,'B','C')) # decode처럼 안에 삽입가능

# [연습문제]
# emp.csv 파일을 읽고,
# new_sal이라는 컬럼 추가, sal이 3000이상인 경우 5%인상,
# 미만은 10%인상
emp$new_sal<-ifelse(emp$SAL>=3000,emp$SAL*1.05,emp$SAL*1.1)
```
------------------------------------------------
------------------------------------------------
### *for문 
- 반복횟수가 정해져 있음

**[기본문법]**
for (반복변수 in 대상 or 횟수) {
  반복처리 
}
```R
for (i in 1:10) {  # i에먼저 1을 담고 범위만큼 반복해 수행
  print(i)
}
=>
[1] 1
[1] 2
...
[1] 9
[1] 10

#예제) v2의 값이 10이면 'A' 아니면 'B'로 출력
v4<-c()
for (i in v2) {       # for문은 대상을 하나씩 꺼내고!!
  if (i==10) {        # 그것을 하나씩 if문에 적용시킨다!!
    v4<-c(v4,'A')     # for문은 리턴값 아닌 실행문장!!
  } else {            
    v4<-c(v4,'B')     
  }                   
  }               

#예제) 1~10을 갖는 벡터에서 5보다 작거나 같은 경우 곱하기1을
#      6이상인 경우는 곱하기 2를 리턴

#1)ifelse
v6<-1:10
ifelse(v6<=5, v6,v6*2)

#2)for+if -- 복잡한 프로그래밍 처리를 하기위해서는 이렇게 해야함
v7<-c()
for (i in v6) {
  if (i<=5) {
    v7<-c(v7,i)
  } else { v7<-c(v7,2*i)
  }
}

# 2)new_sal이라는 컬럼 추가, sal이 3000이상인 경우 5%인상,
#   미만은 10%인상
new_sal<-c()
for (i in emp$SAL) {
  if (i>=3000) {
    new_sal<-c(new_sal,1.05*i)
  } else {
    new_sal<-c(new_sal,1.1*i)
  }
};new_sal 
emp$new_sal<-new_sal
```
---------------------------------------------
---------------------------------------------
### *while문
- 조건 기반 반복문(for문은 정해진 대상/횟수 내 반복)!!
- for문처럼 다음 단계로 자동으로 넘어가지 않음!!
- 조건이 참인 경우 무한 반복 수행

**[기본 문법]**
 while (조건) {
   반복문장
 }
```R
#예제) 1~10까지 출력
j<-1  #초기값
while (j<=10) {
  print(j)
  j<-j+1
}

#[연습문제]
#1~100의 합 출력
j<-1
v_sum<-0
while (j<=100) {
  v_sum<-v_sum+j
  j<-j+1
}
