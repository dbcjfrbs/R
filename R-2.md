```R
# 1. 2019년 전체 날짜를 갖는 v1 변수 생성
v1<-seq(as.Date('2019/01/01'), as.Date('2019/12/31'),1);v1

# 2. 위의 벡터를 년도를 제외한 월/일 형식으로만 출력하여 v2 생성
as.character(v1,'%m/%d')

# 3. '2019/04/25'일로부터 100일 뒤의 날짜와 요일 출력
as.Date('2019/04/25') + 100

v3<-as.Date('2019/04/25')
wday(v3,label=T)

# 4. 사원의 입사일이 다음과 같을때
# 현재까지 근무일수가 몇주, 몇일인가 출력
v_hiredate <- c('2018/04/06','2019/12/23','2019/05/04')
v5 <- as.numeric(Sys.Date()-as.Date(v_hiredate)) %/% 7 ; v5
v4 <- as.numeric(Sys.Date()-as.Date(v_hiredate)) %% 7 ; v4
```
--------------------------
---------------------------
### *R 자료구조
##### 1. 스칼라
##### 2.벡터(vextor)
##### 3.리스트(list)
##### 4.매트릭스(matrix)
##### 5.배열(array)
##### 6.데이터프레임(data.frame)
---------------------------
##### 2.벡터(vextor)
- 1차원
- 단 하나의 데이터타입만 허용, 마치 오라클의 컬럼

```R
### 1.벡터의 생성
v1<-c(1,2,3);v1 
v2<-c('a',1);v2
v3<-1:10;v3


### 2.벡터의 확장
c(v1,4)  # 1 2 3 4, 무조건 맨 끝에 원소를 추가
append(x=v1, values=4, after=2)  # 1 2 4 3 중간에 원소 삽입 가능


### 3.벡터의 산술연산
v4<-c(10,20,30)
v5<-c(10,20,30,40)
v1 + 1  #벡터와 스칼라 연산 가능, 모든 원소에 더함
v1 + v4  #서로 크기가 같은 벡터 연산 가능

v1 + v5 #서로 크기가 다른 벡터는 작은 벡터가 반복연산, **지금은안됨!why?
#   10 20 30 40... 
# +  1  2  3  1...
# --------------


### 4.벡터의 색인(indexing, 추출)
# 4.1) 정수색인
v1 #  1 2 3
v1[1] # 1, 첫번쨰 위치값 추출
v1[1,3] # 에러발생, 1행의 3열을 추출한다는 의미
v1[c(1,3)] # 1 3
v1[-1] # 2 3, 첫번째 원소 제외 추출

-----------------------------------------------------------------
# 참고
df1<-read.csv('emp.csv');df1
df1[1,2] # SMITH

# smith와 allen의 이름, 입사일, 연봉 추출
df1[c(1,2),c(2,5,6)]

# smith와 allen의 이름과 연봉추출
df1[c(1,2),c(2,6)]
df1[c(1,2),c('ENAME','SAL')] # 컬럼이름으로도 가능
df1[1,1]<-7777
-----------------------------------------------------------------

# 4.2) 이름색인
v1<-c(1,2,3)
names(v1)  #벡터의 각 원소이름을 출력
names(v1)<-c('a','b','c');names(v1)  # "a" "b" "c"
v1[c('a','b')] # 이름색인에 -사용 불가
=> # a b 
   # 1 2 

# 4.3) 조건색인(블리언색인)
# T,F
# TRUE,FALSE
v1[c(T,F,F)] #각 논리에 매칭되는 값만 추출
=> # a 
   # 1 

v1<2 #조건에 만족하는 논리값이 반환됨, 값이 추출되지는 않음
=># a     b     c 
  # TRUE FALSE FALSE 

v1[v1<2]
=># a 
  # 1 

# sal이 2000이상인 직원, SAL 추출
df1$SAL>=2000 # df1$는 컬럼을 선택
df1[df1$SAL>=2000,c('ENAME','SAL')] 

# 연습문제
#1)emp.csv 파일을 읽고 10번 부서원의 이름, job, sal 출력
df1[df1$DEPTNO==10,c('ENAME','JOB','SAL')] # = 하나는 대체한다는 뜻
# DEPTNO==10 이렇게쓰면 DEPTNO가 10인 변수값인가의 의미

#2)20번 부서원의 sal의 총 합 출력
sum(df1[df1$DEPTNO==20,'SAL']) 

#3)이름이 SCOTT과 KING인 사람의 이름, 사번, SAL을 출력
df1[df1$ENAME %in% c('SCOTT','KING'), c('ENAME', 'EMPNO', 'SAL')] 
# %in% : 속하는가??의 의미로 진리값 반환
df1[(df1$ENAME=='SCOTT')|(df1$ENAME=='KING'), c('ENAME', 'EMPNO',
                                                'SAL')] # 같은결과 출력 

# 논리연산자
# 1) and 연산자
T&T # TRUE

# 2) or 연산자
T|T # TURE

v1[(1<v1) & (v1<3)]
=># b 
  # 2

# 3) not 연산자
!(v1>1) # 반대 진리값 반환
v1!=1 # FALSE  TRUE  TRUE
!(v1==1)

#예제) v2에서 3보다 작거나 같고 8보다 크거나 같은 값출력
v2<-1:10;v2
v2[(v2<=3)|(v2>=8)]

# 4.4) 슬라이스 색인(연속추출)
v2<-1:10;v2
v2[4:8] # 4 5 6 7 8
v2[c(4,5,6,7,8)] # 4 5 6 7 8


### 5.벡터수정
v1[2]<-20;v1 #  1 20  3, 20으로 수정됨
v2[2:5]<-seq(20,50,10);v2 #  1 20 30 40 50  6  7  8  9 10

#예제)v1벡터에 마지막에 4 삽입, 원소이름을 d부여!!!
v1[4]<-4;v1
names(v1)[4]<-'d';names(v1)

c(v1,4) # 가능

v1<-append(v1,4) # 가능      


### 6.벡터의 크기 확인
length(v1)  # 1차원에 대한 크기
NROW(v1)   # 행의 갯수: 1차원일 때
nrow(v1)  # 행의 갯수: 2차원일 때 가능

# 포함연산자 
(v1==1)|(v1==3)
v1 %in% c(1,2)
1 %in% v1     #v1에 1포함 여부

# 형 확인 함수, 진리값 반환
is.character('a') # TRUE
is.vector(df1) # FALSE
is.na(1) # FALSE
is.null(1) # FALSE

v3<-c(1,NA,3,4)
is.na(v3) # FALSE TRUE FALSE FALSE

#예제) 다음의 v3에서 NA인 원소만 찾아 2로 수정
v3<-c(1,NA,3,4)
v3[is.na(v3)]<-2;v3