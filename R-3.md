#### * is.na
```R
v1<- c(1,2,NA,3,4,NA,5,6)
v2<- c(1,2,NULL,3,4,NULL,5,6)
sum(v1)  # 계산불가
sum(v2)  # 계산가능

is.na(v1)   #이것이 na입니까?의 의미  T,F로 출력
v1[is.na(v1)] <-0
sum(v1)  # 계산가능

c(T,T,T) & c(T,F,T)   # 모든 인자를 체크
c(T,T,T) && c(T,F,T)  # 첫번째만 체크

# 예제) v3에서 7보다 크고 10보다 작은 값 출력
v3<-1:10
v3[v3>7 & v3<10]

# 벡터 연습문제
#1. 2015/01/01~2015/01/31 일별 날짜 생성
v1<-seq(as.Date('2015/01/01'),as.Date('2015/01/31'),1);v1
day(v1)

#감 제외 
vec1<-c('사과','배','감','버섯','고구마');vec1
vec1<-vec1[vec1!='감'];vec1
```
------------------------------------------------------------
------------------------------------------------------------
#### * 집합연산자
```R
vec1<-c('봄','여름','가을','겨울')
vec2<-c('봄','여름','늦여름','초가을')

#1) vec1과vec2를 합한 결과
vec3<-c(vec1,vec2);vec3 # append도 가능

#2) vec1에는 있는데 vec2에는 없는 결과
vec4<-vec1[vec1!=vec2];vec4
setdiff(vec1,vec2)

#3) vec1, vec2에 둘다 있는 결과
vec5<-vec1[vec1==vec2];vec5 # %in% 가능
intersect(vec1,vec2)

------------------------------------------------------------

t1<- c('a','b','c','d')
t2<- c('a','e','f')
t3<- c('a','e','e','f')
# 1)합집합: union
union(t1,t2) # 중복 제외 합집합 출력

# 2)교집합: intersect
intersect(t1,t2)

# 3)차집합: setdiff
setdiff(t1,t2)

# 4)동등비교: identical, setequal
# identical: 구성하는 원소,크기가 모두 같은지 확인
# setequal: 크기 상관없이 구성하는 원소가 모두 같은지 확인
identical(t3,t2) # FALSE
setequal(t3,t2) # TRUE
```
--------------------------------------------------
-------------------------------------------------
### * 리스트
- 층을 가지는 구조, 그렇지만 1차원 구조
- key-value구조: 데이터를 각각의 키(이름,연봉)를 갖는 형식으로 저장
- key 내부는 벡터로 구성, 같은 키내에서는 동일한 데이터 타입만 가능
- 특정 함수의 결과가 리스트로 나올 수 있다
- key-value를 가지는 구조는 list와 dataframe
- 리스트는 데이터를 저장하기 위함이 목표
```R
#1.생성
l1<-list('a'=1,'b'=2,'c'=3) #각 문자가 key, 그안에 숫자데이터 존재
=>
$a
[1] 1

$b
[1] 2

$c
[1] 3

l2<-list('a'=c(1,2),'b'=c(2,3,4),'c'=3);l2
l3<-list('a'=c(1,2),'b'=c(2,3,4),'c'='a');l3 #서로 다른 데이터 허용

#2.색인 
l2$a #벡터만 벡터라고 안알려줌, 벡터내부 데이터형태를 알려줌
     #키색인, 벡터로 리턴
l2['a'] #리스트로 리턴
l2[1] #1층 추출, 리스트로 리턴
l2[c('a','b')]

#예제) l2의 'b'층에 있는 두번째 원소(3) 출력
l2$b[2]
l2['b'][2] # b층에서 2층을 찾으니 출력불가, 앞 결과의 2번째 층 출력 의미

l2[[1]] # 색인 기호 덮어쓰면 vextor로 추출, 1층 추출

#3.수정 
l2$d<-c(1,5,7);l2 #중간위치에는 삽입 안됨
#이러한 자료구조를 만드는 이유는 자료관리를 쉽게 하기 위해서이다

l2$d<-NULL;l2 # key마다 다른 객체이기 때문에 key 삭제가능
l2$b[3]<-40;l2$b

#[참고]
v1<-c(1,2,3)
v1[2]<-NULL;v1 ; #NULL은 저장공간이 없기 때문에 삽입불가

-------------------------------------------------------------
# 연습문제
#1-1. 아래 벡터 생성
# name grade jumsu hakjum
#서재수 4 90 A0
vec1_1<-c('서재수',4,90,'A0');vec1_1
names(vec1_1)<-c('name','grade','jumsu','hakjum');(vec1_1)

#1-2 JUMSU를 성적으로 변경
names(vec1_1)[2]<-'grade';vec1_1
names(vec1_1)[names(vec1_1)=='jumsu']<-'성적';vec1_1

#2-1 아래 리스트 생성
# name grade jumsu hakjum
# 서재수 4 90 A0
# 서진수 3 90 B+
# 홍길동 2 85 B+
l2_1<-list('name'=c('서재수','서진수','홍길동'),'grade'=c(4,3,2),
           'jumsu'=c(90,90,85),'hakjum'=c('A0','B+','B+'));l2_1  
#key구조는 대명사 형식이므로 따옴표 없어도 됨

#2-2. 홍길동의 점수와 HAKJUM을 각각 95, A+로 변경
l2_1[[3]][3]<-95;l2_1[[4]][3]<-'A+';l2_1
l2_1[[3]][l2$'name'=='홍길동']<-95;l2_1[[4]][3]<-'A+';l2_1

#2-3. 서진수의 학점 삭제
l2_1[[4]][2]<-'NULL'; l2_1
vec2_name<-l2_1[[1]];vec2_hakjum<-l2_1[[4]];vec2_hakum[vec2_name=='서진수']
vec2_hakum[vec2_name[vec2_name=='서진수']]
vec2_hakum[vec2_name=='서진수']
# 아니면 NA로 처리, zero length가 아니라서 수정가능
-------------------------------------------------------------
```
--------------------------------------------------------------
--------------------------------------------------------------
### * matrix
- 숫자 저장하는 용도, 벡터가 2차원으로 확장된 모습
- 2차원구조, 행과 열로 구성
- 동일한 데이터 타입만 허용
```R
##1.생성 
#matrix(data=1:9, #matrix구성 데이터
       # nrow=3,   #행의 수
       # ncol=3,   #컬럼 수
       # byrow=T,  #로우 우선순위(T) 여부(F가 기본값)
       # dimnames=) #행과 열의 이름

m1<-matrix(data=1:9,nrow=3)              
m1
# [,1] [,2] [,3]
# [1,]    1    4    7
# [2,]    2    5    8
# [3,]    3    6    9

##2.색인
m1[,1]  # 1 2 3
m1[1,]  #  1 4 7
m1[1,1]
m1[c(1,3),]
m1[,2:3]

#예제) 3번째 컬럼이 9이상인 행 선택
m1[,3]>=9
m1[m1[,3]>=9,]

m1>5 # 조건자체가 2차원이므로 2차원 색인 유지
m1[m1>5] # matrix로 표현 안되므로 1차원으로 풀림

#연습문제) 1부터 20값을 갖는 5*4행렬 생성 후 짝수값을 모두 0 수정
m2<-matrix(1:20,nrow=5)
m2[m2%%2==0]<-0;m2   # %%는 나머지

##3. 컬럼 이름 수정
rownames(m1)<-0:2 # 벡터출력, 위치값이랑 충돌되므로 
                  # 숫자로 부여해도 문자로 저장
colnames(m1)<-c('a','b','c') # 벡터출력
dimnames(m2)<-list(1:5,c('a','b','c','d')) #리스트 출력
dimnames(m2)
# 참고 : 색인시 주의사항
m1[c(2,3),2] #위치색인(숫자전달)
m1[c('1','2'),2] #이름색인(문자전달)

## 4.구조변경
rbind(m1,c(10,11,12))
=>
   a  b  c
0  1  4  7
1  2  5  8
2  3  6  9
  10 11 12

cbind(m1,c(10,11,12))

## 5.연산
m3<- matrix(1:4,nrow=2)
m4<- matrix(c(10,20,30,40),nrow=2)
m5<- matrix(1:6,nrow=2)
m6<- matrix(c(10,20),nrow =2 )
  
m3 + m4 # 크기가 같은 두 행렬 연산가능
m3 + m5 # 크기가 다른 두 행렬 연산불가
m3%*%m6 # 행렬식으로 생각해 가능

## 6.크기확인
nrow(m1) # 행의 수 
ncol(m1) # 열의 수
dim(m1)  # 행, 컬럼 수가 벡터로 동시 출력, 출력결과가 중요 

# 원본 metrix의 행과 열을 바꿀 수 있다
dim(m2)<-c(4,5)

---------------------------------------------------------------
#연습문제
m1_1<-matrix(c('봄','여름','가을','겨울'),nrow=2)
seasons<-matrix(c('봄','여름','가을','겨울'),nrow=2,byrow=T);m1_2

seasons[,2] # ,앞 행이 없다는 뜻, 내가 표현하려는 데이터가 낮은 
            # 차원으로도 표현가능하면 낮게 표현됨
=>
"여름" "겨울"

seasons[,2,drop=F] # drop=F 입력하면 차원이 그대로 유지됨
=>
     [,1]  
[1,] "여름"
[2,] "겨울"

seasons2<-rbind(seasons,c('초봄','초가을'));seasons2

seasons3<-cbind(seasons2,c('초여름','초겨울','한겨울'));seasons3
--------------------------------------------------------------
```
-------------------------------------------------------------
-------------------------------------------------------------
### * 데이터프레임
- 행과 열의 구조를 갖는 2차원 데이터 형식
- 엑셀에서의 표, 데이터베이스에서의 테이블과 유사
- key(컬럼)-value를 갖음
```R
## 1. 생성
df1<-data.frame(name = c('smith','allen','scott'),
           sal  = c(300,900,1000),
           deptno = c(10,20,30),
           stringsAsFactors = F) 

## 2. 구조확인
str(df1) # 오라클의 desc와 유사, structure의 약자 
# 문자형 컬럼은 무조건 factor로 만드려는 속성이 있음, 원하지 않을시
# 위처럼 stringsAsFactors = F 선언

##3. 구조변경
# 1) 행 추가 
df1<-rbind(df1,c('kimg',2000,10)) # 추가할 시 데이터 타입 변경
# chr타입 벡터이므로 들어오면 모든 컬림이 chr타입으로 변경
str(df1) # 모두 chr타입

df1$sal<-as.numeric(df1$sal)
df1$deptno<-as.numeric(df1$deptno)
sum(df1$sal)

df1[5,1]<-'hong' # NA는 데이터 타입을 변경 안시킴 
=>
   name  sal deptno
1 smith  300     10
2 allen  900     20
3 scott 1000     30
4  kimg 2000     10
5  hong   NA     NA

df1[5,2]<-3000
df1[5,3]<-20

# 2)컬럼추가
df1$comm<-c(100,0,NA,500,300)
str(df1)

df1<-cbind(df1,c(7411,7511,7611,7711,9811))
colnames(df1)[5]<-'deptno'

-------------------------------------------------------------
#연습문제
df1<-read.csv('student.csv') # 문자형 컬럼이 factor형
df1<-read.csv('student.csv',stringsAsFactors = F) # chr형
str(df1)
#csv에서 가져올 때 문자형 컬럼이 factor로 고정되게 된다.

#4학년 학생의 키의 평균
mean(df1$HEIGHT)
mean(df1[df1$GRADE==4,'HEIGHT'])
